#pragma once

#include <list>
#include <cstdint>
#include <deque>
#include <map>
#include <optional>
#include <unordered_map>
#include <vector>
#include <functional>

enum class Side : uint8_t { Buy, Sell };

using OrderId = std::uint64_t;

struct Order {
    OrderId id;
    Side side;
    std::int64_t price;   // for limit orders
    std::int64_t qty;     // remaining quantity
    std::uint64_t seq;    // increasing sequence number to preserve time ordering
};

struct Trade {
    std::int64_t price;
    std::int64_t qty;
    OrderId buy_id;
    OrderId sell_id;
};

class OrderBook {
public:
    OrderBook();

    // Returns trades generated by this order.
    std::vector<Trade> add_limit(OrderId id, Side side, std::int64_t price, std::int64_t qty);
    std::vector<Trade> add_market(OrderId id, Side side, std::int64_t qty);

    // Cancel an active order (best-effort). Returns true if found & removed.
    bool cancel(OrderId id);

    std::optional<std::int64_t> best_bid() const;
    std::optional<std::int64_t> best_ask() const;

    // Debug sanity checks (we’ll expand later)
    bool empty() const;

private:
    
struct Level {
    std::list<Order> q; // FIFO with stable iterators
};

    // bids: highest price first
    std::map<std::int64_t, Level, std::greater<>> bids_;
    // asks: lowest price first
    std::map<std::int64_t, Level> asks_;

    // Locate an order for cancel: side + price + seq
    // We’ll keep it simple: (side, price, seq) and search within that level’s deque.
    struct Locator {
    Side side;
    std::int64_t price;
    std::list<Order>::iterator it; // direct handle to the order node
};

std::unordered_map<OrderId, Locator> index_;
std::uint64_t next_seq_;

private:
    std::vector<Trade> match_incoming(Order& incoming);
    void maybe_erase_empty_level(Side side, std::int64_t price);
};
